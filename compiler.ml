#use "code-gen.ml";; 
(* open Assistance;; *)


let file_to_string f =
  let ic = open_in f in
  let s = really_input_string ic (in_channel_length ic) in
  close_in ic;
  s;;

let string_to_asts s = List.map Semantics.run_semantics
                         (Tag_Parser.tag_parse_expressions
                            (Reader.read_sexprs s));;

let primitive_names_to_labels = 
  ["boolean?", "is_boolean"; "float?", "is_float"; "integer?", "is_integer"; "pair?", "is_pair";
    "null?", "is_null"; "char?", "is_char"; "string?", "is_string";
    "procedure?", "is_procedure"; "symbol?", "is_symbol"; "string-length", "string_length";
    "string-ref", "string_ref"; "string-set!", "string_set"; "make-string", "make_string";
    "symbol->string", "symbol_to_string"; 
    "char->integer", "char_to_integer"; "integer->char", "integer_to_char"; "eq?", "is_eq";
    "+", "bin_add"; "*", "bin_mul"; "-", "bin_sub"; "/", "bin_div"; "<", "bin_lt"; "=", "bin_equ";
    (* was added *)
    "apply", "apply_asm"; "car", "car_asm"; "cdr", "cdr_asm"; "cons", "cons_asm"; "set-car!", "set_car_asm"; "set-cdr!", "set_cdr_asm"
    ];;                                                              
    

let make_prologue consts_tbl fvars_tbl =
  let get_const_address const = (get_const_address const consts_tbl) in
  let get_fvar_index fvar = (string_of_int (get_fvar_index fvar fvars_tbl)) in
  let make_primitive_closure (prim, label) =
"    MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, " ^ label  ^ ")
    mov [fvar_tbl + WORD_SIZE * " ^  (get_fvar_index prim) ^ "], rax" in
  let constant_bytes (c, (a, s)) = s in
"
;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include \"compiler.s\"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

section .data
const_tbl:
" ^ (String.concat "\n" (List.map constant_bytes consts_tbl)) ^ "

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS " ^ get_const_address Void ^ "
%define SOB_NIL_ADDRESS " ^ get_const_address (Sexpr Nil) ^ "
%define SOB_FALSE_ADDRESS " ^ get_const_address (Sexpr (Bool false)) ^ "
%define SOB_TRUE_ADDRESS " ^ get_const_address (Sexpr (Bool true)) ^ "

fvar_tbl:
" ^
  (* This line should be adapted to your fvar-addressing scheme. 
     I.e., if you use direct labeling, you should output them here. *)
  (String.concat "\n" (List.map (fun _ -> "dq T_UNDEFINED") fvars_tbl)) ^ "

global main
section .text
main:
    push rbp

    ;; set up the heap
    mov rdi, GB(4)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0
    push qword SOB_NIL_ADDRESS
    push qword T_UNDEFINED
    push rsp
    mov rbp,rsp

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we emulate the missing (define ...) expressions
    ;; for all the primitive procedures.
" ^ (String.concat "\n" (List.map make_primitive_closure primitive_names_to_labels)) ^ "

user_code_fragment:
;;; The code you compiled will be catenated here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.

";;

(* You may populate this variable with a string containing the epilogue.
   You may load it from a file, you may write it here inline, 
   you may just add things to prims.s (which gets catenated with the epilogue variable).
   Whatever floats your boat. You just have to make sure all the required
   primitive procedures are implemented and included in the output assembly. *)
let epilogue = "

car_asm:
push rbp

mov rbp, rsp
mov rsi, PVAR(0)

SKIP_TYPE_TAG rsi, rsi
mov r10, rsi

mov rax,r10
leave

ret


cdr_asm:
push rbp

mov rbp, rsp
mov rsi, PVAR(0)
mov rsi,qword [rsi + 9]
mov r10, rsi

mov rax,r10
leave
ret




cons_asm:
push rbp
mov rbp, rsp
mov rsi, PVAR(0)
mov rax,PVAR(1)
MAKE_PAIR(r10, rsi, rax)
mov rax, r10
leave
ret

set_car_asm:
push rbp
mov rbp, rsp

push rsi
push r10
mov rsi, PVAR(0)




mov r10,PVAR(1)
mov qword [rsi +1],r10

mov rax, SOB_VOID_ADDRESS
pop r10
pop rsi
leave
ret










set_cdr_asm:
push rbp
mov rbp, rsp
push rsi
push r10
mov rsi, PVAR(0)
mov r10,PVAR(1)
mov qword [rsi +9],r10
mov rax, SOB_VOID_ADDRESS
pop r10
pop rsi
leave
ret

apply_asm:
push rbp


mov rbp, rsp
apply_start:


mov rsi, C_P
dec rsi 
mov r9,rsi 




dec r9 
mov r8, qword [rbp+8*(4+rsi)] 
push 5877582 
mov rax,const_tbl+1 


mov r12b, byte[r8]
cmp r12b, T_NIL

je s_p_i_e






n_p_m:  
CAR rcx,r8  
MAKE_PAIR(rbx,rcx,rax)
mov rax, rbx
CDR r8,r8
mov r12b, byte[r8]
inc r9
cmp r12b, T_PAIR
je n_p_m
mov r8,rbx 

s_i_p:


CAR rcx,r8
push rcx


CDR r8,r8

mov r12b, byte[r8]
cmp r12b, T_PAIR


je s_i_p

s_p_i_e:

mov r8,rsi 
dec r8 




r_p:
cmp r8, 0



jle func_ending
push qword[rbp+8*(4+r8)] 
dec r8

jmp r_p

func_ending:
push r9 


mov rax, [rbp+4*8] 
CLOSURE_ENV rsi,rax
push rsi  




mov rsi,qword [rbp + 8 ] 
push rsi

      add r9,5


                      mov r10, qword [rbp]
                      push r10


      F_R_S r9

      CLOSURE_CODE rsi, rax
      pop rbp

      D_A:
      jmp rsi
      mov rax, 0
      leave
      ret













";;

exception X_missing_input_file;;
let tag_enum = (ref 0);;
try
  let infile = Sys.argv.(1) in  
  let code =  (file_to_string "stdlib.scm") ^ (file_to_string infile) in  
  let asts = string_to_asts code in   
  let enumerated_asts = List.map (fun ast -> (incr tag_enum); enumerate_tags ast (!tag_enum)) asts in 
  let consts_tbl = Code_Gen.make_consts_tbl enumerated_asts in  
  let fvars_tbl = Code_Gen.make_fvars_tbl enumerated_asts in  
  let generate = Code_Gen.generate consts_tbl fvars_tbl in  
  let code_fragment = String.concat "\n\n"
                        (List.map
                           (fun ast -> (generate ast) ^ "\n\tcall write_sob_if_not_void")
                           enumerated_asts) in  
  (* clean_exit contains instructions to clean the dummy stack
     and return exit code 0 ("all's well") from procedure main. *)
  let clean_exit = "\n\n\tmov rax, 0\n\tadd rsp, 4*8\n\tpop rbp\n\tret\n; user_code_fragment_end\n\n" in
  let provided_primitives = file_to_string "prims.s" in
                   
  print_string ((make_prologue consts_tbl fvars_tbl)  ^
                  code_fragment ^ clean_exit ^
                    provided_primitives ^ "\n" ^ epilogue)

with Invalid_argument(x) -> raise X_missing_input_file;;
